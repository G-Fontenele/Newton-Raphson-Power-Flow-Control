# -*- coding: utf-8 -*-
"""newton_raphson_power_flow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IuD0ANzo2BXLzjBOgg71yokWgpAzVvLT
"""

import math
import numpy as np
import pandas as pd
import copy

# Controles
Controle_CTAP = True # Nota: Pode ser iniciada como false, e depois alterada para true quando estiver próxima da convergência

# IEEE 14 Bus Test Case - Dados formatados em Python
# Conversão baseada nos dados fornecidos no formato PWF, com valores percentuais já multiplicados por 100.

# ----------------------------------------------------------------------
# DBAR: Dados das barras do sistema elétrico
# Cada entrada: [número, tipo, V (pu), ângulo (°), Pg (MW), Qg (MVAr), Qmin, Qmax, barra controlada,
#                Pl (MW), Ql (MVAr), Sh (MW), área, fator de tensão Vf]
# ----------------------------------------------------------------------

# DBAR = [
#     [1, 2, 1.060, 0.0,   232.4, -16.3, -999, 999, None,   0.0,   0.0,   0.0, 1, None],
#     [2, 1, 1.045, 0.0,   40.4,  44.48, -40.0, 50.0, None, 21.7,  12.7,  0.0, 1, None],
#     [3, 1, 1.010, 0.0,   0.0,  25.67,   0.0, 40.0, None, 94.2,  19.0,  0.0, 1, None],
#     [4, 0, 1.017, 0.0,   0.0,   0.0, -999, 999, None,  47.8,  -3.9,  0.0, 1, None],
#     [5, 0, 1.020, 0.0,    0.0,   0.0, -999, 999, None,   7.6,   1.6,  0.0, 1, None],
#     [6, 1, 1.070, 0.0,   0.0, 11.68,  -6.0, 24.0, None, 11.2,   7.5,  0.0, 1, None],
#     [7, 0, 1.000, 0.0,   0.0,   0.0, -999, 999, None,   0.0,   0.0,  0.0, 1, None],
#     [8, 1, 1.090, 0.0,   0.0,  16.68,  -6.0, 24.0, None,  0.0,   0.0,  0.0, 1, None],
#     [9, 0, 1.060, 0.0,   0.0,   0.0, -999, 999, None,  29.5,  16.6, 19.0, 1, None],
#     [10, 0, 1.054, 0.0,  0.0,   0.0, -999, 999, None,   9.0,   5.8,  0.0, 1, None],
#     [11, 0, 1.059, 0.0,  0.0,   0.0, -999, 999, None,   3.5,   1.8,  0.0, 1, None],
#     [12, 0, 1.070, 0.0,  0.0,   0.0, -999, 999, None,   6.1,   1.6,  0.0, 1, None],
#     [13, 0, 1.051, 0.0,  0.0,   0.0, -999, 999, None,  13.5,   5.8,  0.0, 1, None],
#     [14, 0, 1.038, 0.0,  0.0,   0.0, -999, 999, None,  14.9,   5.0,  0.0, 1, None]
# ]


DBAR = [
    [1, 2, 1.060, 0.0,   232.4, -16.3, -999, 999, None,   0.0,   0.0,   0.0, 1, None],
    [2, 1, 1.045, -5.0,   40.0,  44.48, -40.0, 50.0, None, 21.7,  12.7,  0.0, 1, None],
    [3, 1, 1.010, -13.0,   0.0,  25.67,   0.0, 40.0, None, 94.2,  19.0,  0.0, 1, None],
    [4, 0, 1.017, -10.0,   0.0,   0.0, -999, 999, None,  47.8,  -3.9,  0.0, 1, None],
    [5, 0, 1.020, -8.8,    0.0,   0.0, -999, 999, None,   7.6,   1.6,  0.0, 1, None],
    [6, 1, 1.070, -14.0,   0.0, 11.68,  -6.0, 24.0, None, 11.2,   7.5,  0.0, 1, None],
    [7, 0, 1.000, -13.0,   0.0,   0.0, -999, 999, None,   0.0,   0.0,  0.0, 1, None],
    [8, 1, 1.090, -13.0,   0.0,  16.68,  -6.0, 24.0, None,  0.0,   0.0,  0.0, 1, None],
    [9, 0, 1.060, -15.0,   0.0,   0.0, -999, 999, None,  29.5,  16.6, 19.0, 1, None],
    [10, 0, 1.054, -15.0,  0.0,   0.0, -999, 999, None,   9.0,   5.8,  0.0, 1, None],
    [11, 0, 1.059, -15.0,  0.0,   0.0, -999, 999, None,   3.5,   1.8,  0.0, 1, None],
    [12, 0, 1.070, -15.0,  0.0,   0.0, -999, 999, None,   6.1,   1.6,  0.0, 1, None],
    [13, 0, 1.051, -15.0,  0.0,   0.0, -999, 999, None,  13.5,   5.8,  0.0, 1, None],
    [14, 0, 1.038, -16.0,  0.0,   0.0, -999, 999, None,  14.9,   5.0,  0.0, 1, None]
]

# ----------------------------------------------------------------------
# DLIN: Dados das linhas de transmissão
# Cada entrada: [de, para, circuito, R (%), X (%), B (MVAr), tap, Tmin, Tmax, fase, Bc, Cn, Ce, Ns]
# ----------------------------------------------------------------------
DLIN = [
    [1, 2, 1, 1.938, 5.917, 5.28, 1.0, None, None, 0.0, None, None, None, None],
    [1, 5, 1, 5.403, 22.304, 4.92, 1.0, None, None, 0.0, None, None, None, None],
    [2, 3, 1, 4.699, 19.797, 4.38, 1.0, None, None, 0.0, None, None, None, None],
    [2, 4, 1, 5.811, 17.632, 3.40, 1.0, None, None, 0.0, None, None, None, None],
    [2, 5, 1, 5.695, 17.388, 3.46, 1.0, None, None, 0.0, None, None, None, None],
    [3, 4, 1, 6.701, 17.103, 1.28, 1.0, None, None, 0.0, None, None, None, None],
    [4, 5, 1, 1.335, 4.211, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [4, 7, 1, 0.0, 20.912, 0.0, 0.978, None, None, 0.0, None, None, None, None],
    [4, 9, 1, 0.0, 55.618, 0.0, 0.969, 0.6, 1.4, 0.0, 9, None, None, None],
    [5, 6, 1, 0.0, 25.202, 0.0, 0.932, 0.6, 1.4, 0.0, 5, None, None, None],
    [6, 11, 1, 9.498, 19.890, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [6, 12, 1, 12.291, 25.581, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [6, 13, 1, 6.615, 13.027, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [7, 8, 1, 0.0, 17.615, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [7, 9, 1, 0.0, 11.001, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [9, 10, 1, 3.181, 8.450, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [9, 14, 1, 12.711, 27.038, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [10, 11, 1, 8.205, 19.207, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [12, 13, 1, 22.092, 19.988, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [13, 14, 1, 17.093, 34.802, 0.0, 1.0, None, None, 0.0, None, None, None, None]
]

# ----------------------------------------------------------------------
# Potência base do sistema (MW)
# ----------------------------------------------------------------------
Pbase = 100  # Potência base típica para o sistema IEEE 14 barras

# ----------------------------------------------------------------------
# Tolerância para critério de convergência
# ----------------------------------------------------------------------
tol = 0.0001/Pbase  # em pu


def print_jacobiana_bonita(J, casas_decimais=4):
    """
    Imprime a matriz Jacobiana de forma tabular e legível.
    """
    # Cria rótulos para linhas e colunas
    linhas = [f"L{i}" for i in range(J.shape[0])]
    colunas = [f"C{i}" for i in range(J.shape[1])]

    df = pd.DataFrame(np.round(J, casas_decimais), index=linhas, columns=colunas)
    pd.set_option('display.max_rows', None)
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', None)
    pd.set_option('display.precision', casas_decimais)

    print(df)

    return

# Autor: Gonçalo Fontenele
# Data de criação: 18/05/2025
# Função: montar_ybarra
# Descrição: monta a matriz de admitância nodal Ybarra (completa), incluindo linhas com transformadores,
# defasagens angulares, admitâncias série e shunt por linha e por barra. Retorna também as partes G e B.

def montar_ybarra(NBAR, NLIN, DE, PARA, R, X, BSH, TAP, DEFAS, SHUNT):
    """
    Monta a matriz de admitância Ybarra do sistema.

    Parâmetros:
    - NBAR: número de barras
    - NLIN: número de linhas
    - DE, PARA: listas de barras de origem e destino de cada linha (indexadas a partir de 1)
    - R, X: listas de resistências e reatâncias (pu)
    - BSH: susceptância shunt (pu)
    - TAP: relação de transformação dos transformadores (se for linha normal, TAP = 1)
    - DEFAS: defasagem angular dos trafos (rad)
    - SHUNT: admitância shunt em cada barra (pu)

    Retorna:
    - Ybarra: matriz de admitância completa
    - G: parte real da matriz
    - B: parte imaginária da matriz
    """

    # Inicialização da matriz Ybarra como matriz NBAR x NBAR de números complexos
    Ybarra = np.zeros((NBAR, NBAR), dtype=complex)

    # Cálculo da admitância série de cada linha (Ykm = 1 / Z)
    Ykm = 1 / (R + 1j * X)

    # Cálculo da admitância shunt (representada por susceptância Bsh) de cada linha
    Bsh = 1j * BSH

    # Loop para montagem da matriz Ybarra (somente componentes das linhas)
    for k in range(NLIN):
        x = int(DE[k]) - 1      # índice da barra DE (ajuste de indexação para Python)
        y = int(PARA[k]) - 1    # índice da barra PARA
        tap_k = TAP[k]          # relação de transformação (TAP)
        defas_k = DEFAS[k]      # defasagem angular do trafo (rad)

        # Adição do termo série e shunt da linha na diagonal da barra "de"
        Ybarra[x, x] += Bsh[k] + (1 / tap_k**2) * Ykm[k]

        # Adição do termo série e shunt da linha na diagonal da barra "para"
        Ybarra[y, y] += Bsh[k] + Ykm[k]

        # Termos fora da diagonal com ajuste de tap e defasagem (ângulo)
        Ybarra[x, y] -= Ykm[k] * (1 / tap_k) * np.exp(-1j * defas_k)
        Ybarra[y, x] -= Ykm[k] * (1 / tap_k) * np.exp(1j * defas_k)

    # Adição das admitâncias shunt associadas a cada barra diretamente (elementos da diagonal)
    for k in range(NBAR):
        Ybarra[k, k] += 1j * SHUNT[k]

    # Extração das partes real (G) e imaginária (B) da matriz Ybarra
    G = np.real(Ybarra)
    B = np.imag(Ybarra)

    return Ybarra, G, B

# Autor: Gonçalo Fontenele
# Data de criação: 18/05/2025
# Função: montar_matriz_jacobiana
# Descrição: monta a matriz Jacobiana do método de Newton-Raphson para fluxo de potência,
# considerando barras tipo PQ, PV e Swing. A Jacobiana é composta pelas submatrizes H, N, M, L.

def montar_matriz_jacobiana(NBAR, V, TETA, Pcalc, Qcalc, G, B, TIPO):
    # Inicialização das submatrizes H, N, M, L com zeros (todas são NBAR x NBAR)
    H = np.zeros((NBAR, NBAR))  # Derivadas de P em relação a ângulos (∂P/∂θ)
    N = np.zeros((NBAR, NBAR))  # Derivadas de P em relação a tensões (∂P/∂V)
    M = np.zeros((NBAR, NBAR))  # Derivadas de Q em relação a ângulos (∂Q/∂θ)
    L = np.zeros((NBAR, NBAR))  # Derivadas de Q em relação a tensões (∂Q/∂V)

    # Loop para montar as derivadas de todas as submatrizes
    for k1 in range(NBAR):
        for k2 in range(NBAR):
            if k1 == k2:
                # Elementos diagonais (derivadas parciais considerando a própria barra)
                H[k1, k1] = -(Qcalc[k1] + V[k1]**2 * B[k1, k1])
                N[k1, k1] = (1 / V[k1]) * (Pcalc[k1] + V[k1]**2 * G[k1, k1])
                M[k1, k1] = Pcalc[k1] - V[k1]**2 * G[k1, k1]
                L[k1, k1] = (1 / V[k1]) * (Qcalc[k1] - V[k1]**2 * B[k1, k1])

                # Ajustes com base no tipo da barra
                if TIPO[k1] == 2:  # Barra swing: ângulo e tensão fixos
                    H[k1, k1] = 1e10   # Impede alterações em ∆θ
                    L[k1, k1] = 1e10   # Impede alterações em ∆V
                if TIPO[k1] == 1:  # Barra PV: ângulo e potência ativa fixos
                    L[k1, k1] = 1e10   # Impede alterações em ∆V (Q especificado)
            else:
                # Elementos fora da diagonal (entre barras diferentes)
                delta_theta = TETA[k1] - TETA[k2]

                # Derivadas parciais conforme a equação do fluxo de potência
                H[k1, k2] = V[k1] * V[k2] * (G[k1, k2] * np.sin(delta_theta) - B[k1, k2] * np.cos(delta_theta))
                N[k1, k2] = V[k1] * (G[k1, k2] * np.cos(delta_theta) + B[k1, k2] * np.sin(delta_theta))
                M[k1, k2] = -V[k1] * V[k2] * (G[k1, k2] * np.cos(delta_theta) + B[k1, k2] * np.sin(delta_theta))
                L[k1, k2] = V[k1] * (G[k1, k2] * np.sin(delta_theta) - B[k1, k2] * np.cos(delta_theta))

    # Montagem da matriz Jacobiana 2*NBAR x 2*NBAR com as 4 submatrizes
    Jac = np.block([[H, N],   # Parte superior (∂P/∂θ | ∂P/∂V)
                    [M, L]])  # Parte inferior (∂Q/∂θ | ∂Q/∂V)

    return Jac

def adiciona_controles_delta_y(DELTA_Y, V, V_CONTROLADA, LC):
    """
    Adiciona equações de controle de tensão (tap controlado) ao vetor ΔY.
    """
    # Garante que DELTA_Y é vetor 1D para concatenar
    DELTA_Y = DELTA_Y.flatten()

    taps_controlados = sum(1 for barra in LC if barra is not None)
    deltaY = np.concatenate([DELTA_Y, np.zeros(taps_controlados)])

    for tap_count, barra_controlada in enumerate([b for b in LC if b is not None]):
        idx = len(deltaY) - taps_controlados + tap_count
        print("TEnsaõ cal", V[barra_controlada - 1])
        deltaY[idx] = V_CONTROLADA[barra_controlada - 1] - V[barra_controlada - 1]

    return deltaY.reshape(-1, 1)  # Retorna como vetor coluna

def adicionar_controles_jacobiana(NBAR, JACOBIANA, V, TETA, G, B, TIPO, TAP, DE, PARA, BC, LC):
    """
    Adiciona controles de tap variável na matriz Jacobiana.

    Parâmetros:
        NBAR        : número de barras
        JACOBIANA   : matriz Jacobiana original (2NBAR x 2NBAR)
        V           : vetor de tensões [pu]
        TETA        : vetor de ângulos [rad]
        G, B        : matrizes de condutâncias e susceptâncias
        TIPO        : vetor com tipos de barras (0=PQ, 1=PV, 2=Slack)
        TAP         : vetor de taps atuais
        DE, PARA    : vetores de origem/destino das linhas
        BC          : vetor de barras controladas (não usado diretamente aqui)
        LC          : vetor com número da barra controlada por cada transformador (None se não houver controle)

    Retorna:
        Jacobiana ampliada com colunas e linhas extras para controle de TAP.
    """

    taps_ativos_idx = [i for i, b in enumerate(LC) if b is not None]

    # Inicializa Jacobiana ampliada com blocos extras
    nVARIAVEIS = 2 * NBAR
    nTAPS = len(taps_ativos_idx)

    J = JACOBIANA.copy()
    zeros_col = np.zeros((J.shape[0], nTAPS))
    zeros_row = np.zeros((nTAPS, J.shape[1]))
    zeros_corner = np.zeros((nTAPS, nTAPS))

    J = np.block([
        [J,         zeros_col],
        [zeros_row, zeros_corner]
    ])

    for tap_count, k in enumerate(taps_ativos_idx):
        barra_controlada = LC[k]
        barra_k = DE[k] - 1
        barra_m = PARA[k] - 1

        print("Analisando barra controlada:", barra_controlada)
        print("Conexão de trafo")
        print("De:", barra_k + 1)
        print("Para:", barra_m + 1)

        # Dados da linha
        gkm = G[barra_k, barra_m]
        bkm = B[barra_k, barra_m]

        # Tensões e ângulos
        Vk = V[barra_k]
        Vm = V[barra_m]
        teta_k = TETA[barra_k]
        teta_m = TETA[barra_m]
        tap = TAP[k] if TAP[k] != 0 else 1.0

        # Índices na Jacobiana
        idx_theta_k = barra_k
        idx_theta_m = barra_m
        idx_v_k = NBAR + barra_k
        idx_v_m = NBAR + barra_m
        idx_tap = 2 * NBAR + tap_count

        # Derivadas das potências em relação ao TAP
        dPk_da = 2 * tap * Vk**2 * gkm - Vk * Vm * (gkm * np.cos(teta_k - teta_m) + bkm * np.sin(teta_k - teta_m))
        dPm_da = -Vk * Vm * (gkm * np.cos(teta_m - teta_k) - bkm * np.sin(teta_m - teta_k))
        dQk_da = -2 * tap * Vk**2 * bkm + Vk * Vm * (bkm * np.cos(teta_k - teta_m) - gkm * np.sin(teta_k - teta_m))
        dQm_da = Vk * Vm * (bkm * np.cos(teta_m - teta_k) + gkm * np.sin(teta_m - teta_k))

        # Preenchimento na Jacobiana
        # dPk/da
        J[idx_theta_k, idx_tap] += dPk_da

        # dPm/da
        J[idx_theta_m, idx_tap] += dPm_da

        # dQk/da (se barra k for PQ)
        J[idx_v_k, idx_tap] += dQk_da

        # dQm/da (se barra m for PQ)
        J[idx_v_m, idx_tap] += dQm_da

        # dV/dV (se barra m for PQ)
        # A tensão barra controlada fica na segunda parte do delta y, que foi montado concatenando Delta P e em seguida Delta Q
        J[idx_tap, NBAR + (barra_controlada-1)] += 1 # Feito considerando que a parte superior é uma constante


    return J

def atualiza_taps(TAPS, delta_SOLUCAO, LC, NBAR):
    """
    Atualiza os valores dos taps que estão controlando tensões.

    Parâmetros:
    - TAPS: vetor atual de taps
    - delta_SOLUCAO: vetor solução da iteração atual (delta_theta, delta_V, delta_taps)
    - LC: lista de controle de tensão por tap (None se não controla)
    - NVARIAVEIS: número de variáveis antes das variáveis de tap (theta + V_PQ)

    Retorna:
    - TAPS atualizado
    """
    taps_controlados_idx = [i for i, barra in enumerate(LC) if barra is not None]
    print(taps_controlados_idx)

    for pos, idx_tap in enumerate(taps_controlados_idx):
        TAPS[idx_tap] += delta_SOLUCAO[2*NBAR + pos]
        print(f"Tap {idx_tap} atualizado para {TAPS[idx_tap]}")

    return TAPS

def relatorio_transformadores(DE, PARA, FLUXO, TAP, LC, nomes_barras=None):
    """
    Imprime um relatório no estilo ANAREDE para transformadores/linhas com tap.

    Parâmetros:
    - DE, PARA: listas de barras de origem e destino
    - FLUXO: matriz com colunas [Pkm, Pmk, Pkm_max, folga, fluxo_utilizado, Qkm]
    - TAP: vetor de taps atuais
    - LC: lista de barras controladas (None se não houver controle)
    - nomes_barras: lista com nomes das barras (opcional)
    """

    print("\nRELATÓRIO DE TRANSFORMADORES COM CONTROLE DE TAP")
    print("X-------X-----------------X-----X-----------------X-----X-------X-------X--------X")
    print(" DE     NOME_ORIGEM       NC    PARA   NOME_DESTINO     MW     Mvar    MVA     TAP  TIPO")
    print("X-------X-----------------X-----X-----------------X-----X-------X-------X--------X")

    for k in range(len(DE)):
        de = DE[k]
        para = PARA[k]
        nome_de = nomes_barras[de - 1] if nomes_barras else f"Barra-{de:02d}"
        nome_para = nomes_barras[para - 1] if nomes_barras else f"Barra-{para:02d}"

        pkm = FLUXO[k, 0]
        qkm = FLUXO[k, 5] if FLUXO.shape[1] > 5 else 0.0
        mva = (pkm**2 + qkm**2)**0.5
        tap = TAP[k]
        tipo = "*" if LC[k] is not None else "F"  # * para variável, F para fixo

        print(f" {de:<7} {nome_de:<17} 1     {para:<5} {nome_para:<17} {pkm:7.1f} {qkm:7.1f} {mva:7.1f}  {tap:6.3f}   {tipo:>2}")

    print("X-------X-----------------X-----X-----------------X-----X-------X-------X--------X")
    return

def relatorio_barras(DBAR, V, TETA, Pcalc, Qcalc, PD, QD, QN, QM, nomes_barras=None, Pbase=1.0):
    # Corrige caso DBAR esteja mal aninhado

    print("X--------------------------X  F L U X O  D E  C A R G A  X---------------------------X")
    print(f'{"Nº":<4} {"BARRA":<18} {"V (pu)":>7} {"Ângulo":>8} {"PG":>10} {"QG":>10} {"Qmin":>10} {"Qmax":>10} {"PD":>10} {"QD":>10}')
    print('-'*108)

    for k in range(len(DBAR)):
        nome = nomes_barras[k] if nomes_barras else f"Barra-{k+1:02d}"
        tensao = V[k]
        angulo = np.degrees(TETA[k])
        pg = (Pcalc[k] + PD[k]) * Pbase
        qg = (Qcalc[k] + QD[k]) * Pbase
        pd = PD[k] * Pbase
        qd = QD[k] * Pbase
        qmin = QN[k] * Pbase
        qmax = QM[k] * Pbase

        print(f'{k+1:<4} {nome:<18} {tensao:>7.4f} {angulo:>8.2f} {pg:>10.2f} {qg:>10.2f} {qmin:>10.2f} {qmax:>10.2f} {pd:>10.2f} {qd:>10.2f}')
    return

def newton_raphson_flow(DBAR, DLIN, Pbase = 1.0, tolerancia = 0.003, iteracao_max = 20, printar_relatorio=True):
    tolerancia_tensao = tolerancia/0.1
    # Número de barras (NBAR)
    NBAR = len(DBAR)  # número de linhas da lista DBAR

    # Número de linhas (NLIN) e número de colunas (AUX) da matriz DLIN
    NLIN = len(DLIN)        # número de linhas da lista DLIN

    # --- Separação de DBAR em vetores numpy (ordenados por índice) ---
    # DBAR contém os dados das barras do sistema

    TIPO = np.array([row[1] for row in DBAR])            # Tipo da barra (1 = PQ, 2 = PV, 3 = Slack)
    V = np.array([row[2] for row in DBAR])               # Módulo da tensão (em pu)
    V_ESP = copy.deepcopy(V)    
    TETA = np.array([row[3] * math.pi / 180 for row in DBAR])  # Ângulo da tensão (graus → rad)
    TETA_ESP = copy.deepcopy(TETA)
    PG = np.array([row[4] / Pbase for row in DBAR])      # Potência ativa gerada (MW → pu)
    QG = np.array([row[5] / Pbase for row in DBAR])      # Potência reativa gerada (MVAr → pu)
    QN = np.array([row[6] / Pbase for row in DBAR])      # Limite inferior da geração reativa (MVAr → pu)
    QM = np.array([row[7] / Pbase for row in DBAR])      # Limite superior da geração reativa (MVAr → pu)
    BC = np.array([row[8] for row in DBAR])             # Barra controlada (se houver)
    PD = np.array([row[9] / Pbase for row in DBAR])      # Potência ativa demandada (MW → pu)
    QD = np.array([row[10] / Pbase for row in DBAR])     # Potência reativa demandada (MVAr → pu)
    SHUNT = np.array([row[11] / Pbase for row in DBAR])  # Susceptância do shunt (MVAr → pu)

    # --- Separação de DLIN em vetores numpy (ordenados por índice) ---
    # DLIN contém os dados das linhas do sistema

    DE = np.array([row[0] for row in DLIN])              # Barra de origem da linha
    PARA = np.array([row[1] for row in DLIN])            # Barra de destino da linha
    R = np.array([row[3] / 100 for row in DLIN])         # Resistência série da linha (% → pu)
    X = np.array([row[4] / 100 for row in DLIN])         # Reatância série da linha (% → pu)
    BSH = np.array([(row[5] / 2) / Pbase for row in DLIN])  # Susceptância total da linha (dividida entre as extremidades e normalizada)
    TAP = np.array([row[6] for row in DLIN])             # Tap da linha (se houver transformador, normalmente ≠ 1)
    DEFAS = np.array([row[9] for row in DLIN])           # Defasagem angular associada ao tap (em graus ou rad, conforme o caso)
    LC = np.array([row[10] for row in DLIN])            # Barra/Linha controlada

    # Seleção das Barras PV (TIPO == 1)
    PV = np.where(TIPO == 1)[0]
    NPV = len(PV)

    # Seleção das Barras PQ (TIPO == 0)
    PQ = np.where(TIPO == 0)[0]
    NPQ = len(PQ)

    # Contabilização do numero de barras controladas
    NCTAP = sum(1 for barra in LC if barra is not None)
    NCV = sum(1 for barra in BC if barra is not None)

    # Matriz de Fluxo nas Linhas (5 colunas)
    FLUXO = np.zeros((NLIN, 6))  # Adiciona uma coluna extra para o fluxo reativo
    FLUXO[:, 2] = np.array([linha[12] if len(linha) > 14 else 0 for linha in DLIN])  # PkmMAX

    # Inicialização
    i = 0  # Número de Iterações

    convergiu = False  # Flag para verificar divergência

    while not convergiu and i < (iteracao_max+1):
        # Tensões em coordenadas retangulares (TETA em radianos)
        x = V * np.cos(TETA)
        y = V * np.sin(TETA)
        Vret = x + 1j * y  # Forma retangular da tensão

        # Valores Especificados de Potência (Líquido)
        Pesp = PG - PD
        Qesp = QG - QD

        # if proximo_convergencia:
        #     Controle_CTAP = True
        # else:
        #     Controle_CTAP = False

        # Montagem da matriz Ybarra, somente se na primeira iteração ou se houver algum controle ativo
        Ybarra, G, B = montar_ybarra(NBAR, NLIN, DE, PARA, R, X, BSH, TAP, DEFAS, SHUNT)

        # NOTA:
        # AQUI SERÁ NECESSÁRIO ALTERAR A YBARRA SEMPRE QUE TIVER UM CONTROLE ACIONADO
        # ACREDITO QUE DÊ PARA RODAR ALGUMAS ITERAÇÕES E TER DUAS TOLERÂNCIAS
        # CHEGANDO EM 30 % DA TOLERÂNCIA MÁXIMA, SOLTARIA OS CONTROLES

        # Correntes injetadas: I = Ybarra * V
        I = Ybarra @ Vret  # Produto matricial

        # Potência complexa injetada: S = V * conj(I)
        S = Vret * np.conj(I)
        Pcalc = np.real(S)  # Potência ativa calculada
        Qcalc = np.imag(S)  # Potência reativa calculada

        # Inicialização dos resíduos
        delta_P = Pesp - Pcalc
        delta_Q = Qesp - Qcalc

        # Ajuste dos resíduos com base no tipo de barra
        for k in range(NBAR):
            if TIPO[k] == 2:  # Slack (tipo 2): não há resíduos
                delta_P[k] = 0
                delta_Q[k] = 0
            elif TIPO[k] == 1:  # PV (tipo 1): não há resíduo de Q
                delta_Q[k] = 0

        # Vetor de resíduos (coluna)
        delta_Y = np.concatenate([delta_P, delta_Q]).reshape(-1, 1)
        if Controle_CTAP:
            # delta_Y = adiciona_controles_delta_y(delta_Y, V, V_ESP, LC)
            taps_controlados = sum(1 for barra in LC if barra is not None)
            deltaV = np.zeros(taps_controlados)

            for tap_count, barra_controlada in enumerate([b for b in LC if b is not None]):
                deltaV[tap_count] = V_ESP[barra_controlada - 1] - V[barra_controlada - 1]

            deltaV = deltaV.reshape(-1, 1)

            # Erro máximo (critério de convergência)
            MAX_V = np.max(np.abs(deltaV))
            indice_MAX_V = np.argmax(np.abs(deltaV))
            print('Mismatch máximo está em', MAX_V, 'no item', indice_MAX_V)

        # Erro máximo (critério de convergência)
        MAX_Y = np.max(np.abs(delta_Y))
        indice_MAX_Y = np.argmax(np.abs(delta_Y))
        print('Mismatch máximo está em', MAX_Y, 'no item', indice_MAX_Y)

        if MAX_Y < tolerancia:
          convergiu = True
          if Controle_CTAP:
            if MAX_V < tolerancia_tensao:
                convergiu = True
                break
            else:
                break

        if Controle_CTAP:
            delta_Y = np.concatenate([delta_Y, deltaV]).reshape(-1, 1)

        i += 1  # Incrementa o contador de iterações
        print("Iniciando iteracao ", i)

        # Matriz Jacobiana
        Jac = montar_matriz_jacobiana(NBAR, V, TETA, Pcalc, Qcalc, G, B, TIPO)
        if Controle_CTAP:
            Jac = adicionar_controles_jacobiana(NBAR, Jac, V, TETA, G, B, TIPO, TAP, DE, PARA, BC, LC)

        # NOTA:
        # PENSO EM TALVEZ ADICIONAR INFORMAÇÕES APÓS MONTAR A JACOBIANA PADRÃO
        # ELA SEMPRE TERÁ SEU PADRÃO IGUAL, SÓ ALTERADO PELA Y BARRA QUE JÁ FOI ALTERADA ANTES
        # DESSA FORMA, PODEMOS SEMPRE ADICIONAR OS CONTROLES EM SEGUIDA
        # TALVEZ COM UMA FUNÇÃO adicionar_controles_jacobiana
        # Também deve ser adicionado um valor ao delta_y

        # delta_Y deve ser um vetor coluna numpy com dimensão (2*NBAR, 1)
        # Jac é a matriz Jacobiana 2*NBAR x 2*NBAR

        # Resolução do sistema linear: Jac * delta_SOLUCAO = delta_Y
        delta_SOLUCAO = np.linalg.solve(Jac, delta_Y).flatten()

        # Atualização dos vetores TETA e V
        TETA += delta_SOLUCAO[0:NBAR]            # primeiros NBAR elementos são delta_TETA
        V += delta_SOLUCAO[NBAR:2*NBAR]             # próximos NBAR elementos são delta_V

        if Controle_CTAP:
            TAP = atualiza_taps(TAP, delta_SOLUCAO, LC, NBAR)

    for k in range(NLIN):
        K = DE[k] - 1
        M = PARA[k] - 1

        tap = TAP[k] if TAP[k] != 0 else 1.0
        defas = DEFAS[k]

        Vk = V[K]
        Vm = V[M]
        teta_k = TETA[K]
        teta_m = TETA[M]
        gkm = G[K, M]
        bkm = B[K, M]
        bsh = BSH[k]

        delta_km = (teta_k - teta_m) + defas
        delta_mk = (teta_m - teta_k) + defas

        # Fluxo de potência ativa
        fluxo_1 = -(tap * Vk)**2 * gkm + tap * Vk * Vm * (gkm * np.cos(delta_km) + bkm * np.sin(delta_km))
        fluxo_2 = -(tap * Vm)**2 * gkm + tap * Vm * Vk * (gkm * np.cos(delta_mk) + bkm * np.sin(delta_mk))

        # Fluxo de potência reativa
        reat_1 = -(tap**2) * (bsh + bkm) * Vk**2 + tap * Vk * Vm * (bkm * np.cos(delta_km) - gkm * np.sin(delta_km))
        reat_2 = -(tap**2) * (bsh + bkm) * Vm**2 + tap * Vm * Vk * (bkm * np.cos(delta_mk) - gkm * np.sin(delta_mk))

        # Conversão para base real (MW, MVAr)
        fluxo_1 *= Pbase
        fluxo_2 *= Pbase
        reat_1 *= Pbase
        reat_2 *= Pbase

        FLUXO[k, 0] = fluxo_1  # Pkm
        FLUXO[k, 1] = fluxo_2  # Pmk

        if abs(fluxo_1) >= abs(fluxo_2):
            FLUXO[k, 3] = FLUXO[k, 2] - abs(fluxo_1)
            FLUXO[k, 4] = abs(fluxo_1)
            FLUXO[k, 5] = reat_1  # fluxo reativo direto
        else:
            FLUXO[k, 3] = FLUXO[k, 2] - abs(fluxo_2)
            FLUXO[k, 4] = abs(fluxo_2)
            FLUXO[k, 5] = reat_2  # fluxo reativo reverso

    if printar_relatorio:
        if not convergiu:
            print('X--------------------------X  F L U X O  D E  C A R G A  X---------------------------X')
            print('O caso D I V E R G I U após', i, 'iterações.')
            print('X-------------------------------------------------------------------------------X')
        else:
            print('X--------------------------X  F L U X O  D E  C A R G A  X---------------------------X')
            print(f'→ Convergência obtida em {i} iterações')
            print(f'→ Resíduo Máximo: {MAX_Y:.6g} < Tolerância de {tolerancia:.6f}')
            print('X-------------------------------------------------------------------------------X')
            nomes = [f"Barra-{i+1:02d}" for i in range(NBAR)]
            relatorio_barras(DBAR, V, TETA, Pcalc, Qcalc, PD, QD, QN, QM, nomes, Pbase=100)
            print('X-------------------------------------------------------------------------------X')
            relatorio_transformadores(DE, PARA, FLUXO, TAP, LC, nomes_barras=nomes)

    return V, TETA, FLUXO

tensoes, thetas, fluxos = newton_raphson_flow(DBAR, DLIN, Pbase = Pbase, tolerancia = tol, iteracao_max=20)
