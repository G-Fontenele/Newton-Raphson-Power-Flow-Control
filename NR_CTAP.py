# -*- coding: utf-8 -*-
"""newton_raphson_power_flow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IuD0ANzo2BXLzjBOgg71yokWgpAzVvLT
"""

import math
import numpy as np
import pandas as pd
import copy

# Controles
Controle_CTAP = True # Nota: Pode ser iniciada como false, e depois alterada para true quando estiver próxima da convergência

# # ----------------------------------------------------------------------
# # DBAR: Dados das barras do sistema elétrico (formato de lista de listas)
# # Cada sublista representa uma barra com seus parâmetros:
# # ----------------------------------------------------------------------
# # [
# #   número da barra (int),
# #   tipo da barra (int):
# #       0 = PQ (barra de carga),
# #       1 = PV (barra geradora),
# #       2 = barra swing (barra slack),
# #   tensão nominal (pu) (float),
# #   ângulo da tensão (graus ou radianos dependendo do contexto) (float),
# #   potência ativa gerada Pg (pu) (float),
# #   potência reativa gerada Qg (pu) (float),
# #   potência reativa mínima Qmin (pu) (float),
# #   potência reativa máxima Qmax (pu) (float),
# #   barra controlada (int ou None): barra associada para controle de tensão (exemplo: para barras PV),
# #   potência ativa da carga Pl (pu) (float),
# #   potência reativa da carga Ql (pu) (float),
# #   potência da injeção do gerador Sh (pu) (float), se aplicável,
# #   área de controle ou área elétrica (int ou None),
# #   fator de tensão Vf (float ou None): fator usado em alguns modelos de tensão
# # ]
# DBAR = [
#     [1, 2, 1.00, 0, 0, 0, -999, 999, None, 0, 0, 0, None, None],
#     [2, 0, 1.00, 0, 0, 0, -999, 999, None, 0.472, -0.07, 0, None]
# ]

# # ----------------------------------------------------------------------
# # DLIN: Dados das linhas de transmissão (formato de lista de listas)
# # Cada sublista representa uma linha com seus parâmetros:
# # ----------------------------------------------------------------------
# # [
# #   barra "de" (int): barra inicial da linha,
# #   barra "para" (int): barra final da linha,
# #   circuito (int ou None): identificador de circuito da linha,
# #   resistência R (ohms ou pu) (float),
# #   reatância X (ohms ou pu) (float),
# #   susceptância de linha Mvar (float),
# #   tap (float): relação do transformador de tensão / tap changer,
# #   Tmin (float ou None): valor mínimo permitido do tap,
# #   Tmax (float ou None): valor máximo permitido do tap,
# #   fase (float): ângulo de fase do transformador ou linha,
# #   Bc (float ou None): susceptância de linha em shunt,
# #   Cn (float ou None): parâmetro adicional (exemplo, capacidade nominal),
# #   Ce (float ou None): parâmetro adicional (exemplo, capacidade emergencial),
# #   Ns (int ou None): número de subconjuntos ou circuitos paralelos
# # ]
# DLIN = [
#     [1, 2, None, 20, 100, 0.04, 1, None, None, 0, None, None, 0, None]
# ]

# # ----------------------------------------------------------------------
# # Pbase: Potência base do sistema (em MW ou pu, conforme contexto)
# # Usada para normalizar as potências no sistema, facilitando cálculos.
# Pbase = 1

# # ----------------------------------------------------------------------
# # tol: Tolerância para critério de convergência do método (resíduo máximo
# # aceito para potência ativa e reativa, por exemplo em MW ou pu)
# # Quando os resíduos ficarem abaixo dessa tolerância, o método para.
# tol = 0.003  # Critério de convergência para delta P e delta Q

# '''
# Sistema IEEE 30 Barras
# Dados das linhas de transmissão - Matriz DLIN

# Cada linha contém:
# [De, Para, R (pu), X (pu), Bshunt (pu), Tap, Defasagem (graus), PkmMAX (MW)]

# Descrição dos campos:
# - De, Para         : Barras de origem e destino
# - R (pu)           : Resistência em pu referenciada à base do sistema
# - X (pu)           : Reatância em pu referenciada à base do sistema
# - Bshunt (pu)      : Susceptância total de linha (1/2 em cada extremidade)
# - Tap              : Tap do transformador (1.0 se não houver)
# - Defasagem (°)    : Defasagem angular em graus (0 se não houver defasador)
# - PkmMAX (MW)      : Capacidade limite de fluxo ativo na linha (MW)

# Observações:
# - Linhas sem transformadores possuem Tap = 1.0 e Defasagem = 0.
# - Valores de R, X e Bshunt estão normalizados em pu.
# - PkmMAX pode ser usado para restrições térmicas ou análise de contingências.
# '''

# # ----------------------------------------------------------------------
# # DBAR: Dados das barras do sistema elétrico
# # Cada entrada: [número, tipo, V (pu), ângulo (°), Pg (MW), Qg (MVAr), Qmin, Qmax, barra controlada,
# #                Pl (MW), Ql (MVAr), Sh (MW), área, fator de tensão Vf]
# # ----------------------------------------------------------------------

# DBAR = [
#     [1, 2, 1.060, 0.0,   260.2, -16.1, 0.0, 0.0, None,   0.0,   0.0,  0.0, 1, None],
#     [2, 1, 1.043, -5.0,   40.0,  50.0, -40.0, 50.0, None, 21.7,  12.7, 0.0, 1, None],
#     [3, 0, 1.021, -7.0,    0.0,   0.0, 0.0, 0.0, None,    2.4,   1.2, 0.0, 1, None],
#     [4, 0, 1.012, -9.0,    0.0,   0.0, 0.0, 0.0, None,    7.6,   1.6, 0.0, 1, None],
#     [5, 1, 1.010, -14.0,   0.0,  37.0, -40.0, 40.0, None, 94.2,  19.0, 0.0, 1, None],
#     [6, 0, 1.010, -11.0,   0.0,   0.0, 0.0, 0.0, None,    0.0,   0.0, 0.0, 1, None],
#     [7, 0, 1.002, -13.0,   0.0,   0.0, 0.0, 0.0, None,   22.8,  10.9, 0.0, 1, None],
#     [8, 1, 1.010, -12.0,   0.0,  37.3, -10.0, 40.0, None, 30.0,  30.0, 0.0, 1, None],
#     [9, 0, 1.051, -14.0,   0.0,   0.0, 0.0, 0.0, None,    0.0,   0.0, 0.0, 1, None],
#     [10,0, 1.045, -15.0,   0.0,   0.0, 0.0, 0.0, None,    5.8,   2.0,19.0, 1, None],
#     [11,1, 1.082, -14.0,   0.0,  16.2, -6.0, 24.0, None,  0.0,   0.0, 0.0, 1, None],
#     [12,0, 1.057, -15.0,   0.0,   0.0, 0.0, 0.0, None,   11.2,   7.5, 0.0, 1, None],
#     [13,1, 1.071, -15.0,   0.0,  10.6, -6.0, 24.0, None,  0.0,   0.0, 0.0, 1, None],
#     [14,0, 1.042, -16.0,   0.0,   0.0, 0.0, 0.0, None,    6.2,   1.6, 0.0, 1, None],
#     [15,0, 1.038, -16.0,   0.0,   0.0, 0.0, 0.0, None,    8.2,   2.5, 0.0, 1, None],
#     [16,0, 1.045, -15.0,   0.0,   0.0, 0.0, 0.0, None,    3.5,   1.8, 0.0, 1, None],
#     [17,0, 1.040, -16.0,   0.0,   0.0, 0.0, 0.0, None,    9.0,   5.8, 0.0, 1, None],
#     [18,0, 1.028, -16.0,   0.0,   0.0, 0.0, 0.0, None,    3.2,   0.9, 0.0, 1, None],
#     [19,0, 1.026, -17.0,   0.0,   0.0, 0.0, 0.0, None,    9.5,   3.4, 0.0, 1, None],
#     [20,0, 1.030, -16.0,   0.0,   0.0, 0.0, 0.0, None,    2.2,   0.7, 0.0, 1, None],
#     [21,0, 1.033, -16.0,   0.0,   0.0, 0.0, 0.0, None,   17.5,  11.2, 0.0, 1, None],
#     [22,0, 1.033, -16.0,   0.0,   0.0, 0.0, 0.0, None,    0.0,   0.0, 0.0, 1, None],
#     [23,0, 1.027, -16.0,   0.0,   0.0, 0.0, 0.0, None,    3.2,   1.6, 0.0, 1, None],
#     [24,0, 1.021, -16.0,   0.0,   0.0, 0.0, 0.0, None,    8.7,   6.7, 4.3, 1, None],
#     [25,0, 1.017, -16.0,   0.0,   0.0, 0.0, 0.0, None,    0.0,   0.0, 0.0, 1, None],
#     [26,0, 1.000, -16.0,   0.0,   0.0, 0.0, 0.0, None,    3.5,   2.3, 0.0, 1, None],
#     [27,0, 1.023, -15.0,   0.0,   0.0, 0.0, 0.0, None,    0.0,   0.0, 0.0, 1, None],
#     [28,0, 1.007, -11.0,   0.0,   0.0, 0.0, 0.0, None,    0.0,   0.0, 0.0, 1, None],
#     [29,0, 1.003, -17.0,   0.0,   0.0, 0.0, 0.0, None,    2.4,   0.9, 0.0, 1, None],
#     [30,0, 0.992, -17.0,   0.0,   0.0, 0.0, 0.0, None,   10.6,   1.9, 0.0, 1, None]
# ]


# # ----------------------------------------------------------------------
# # DLIN: Dados das linhas de transmissão
# # Cada entrada: [de, para, circuito, R (%), X (%), B (MVAr), tap, Tmin, Tmax, fase, Bc, Cn, Ce, Ns]
# # ----------------------------------------------------------------------
# DLIN = [
#     [1, 2, 1, 1.920, 5.750, 5.280, 1.0, None, None, 0.0, None, None, None, None],
#     [1, 3, 1, 4.520, 16.520, 4.080, 1.0, None, None, 0.0, None, None, None, None],
#     [2, 4, 1, 5.700, 17.370, 3.680, 1.0, None, None, 0.0, None, None, None, None],
#     [3, 4, 1, 1.320, 3.790, 0.840, 1.0, None, None, 0.0, None, None, None, None],
#     [2, 5, 1, 4.720, 19.830, 4.180, 1.0, None, None, 0.0, None, None, None, None],
#     [2, 6, 1, 5.810, 17.630, 3.740, 1.0, None, None, 0.0, None, None, None, None],
#     [4, 6, 1, 1.190, 4.140, 0.900, 1.0, None, None, 0.0, None, None, None, None],
#     [5, 7, 1, 4.600, 11.600, 2.040, 1.0, None, None, 0.0, None, None, None, None],
#     [6, 7, 1, 2.670, 8.200, 1.700, 1.0, None, None, 0.0, None, None, None, None],
#     [6, 8, 1, 1.200, 4.200, 0.900, 1.0, None, None, 0.0, None, None, None, None],
#     [6, 9, 1, 0.000, 20.800, 0.000, 0.978, None, None, 0.0, None, None, None, None],
#     [6, 10, 1, 0.000, 55.600, 0.000, 0.969, None, None, 0.0, None, None, None, None],
#     [9, 11, 1, 0.000, 20.800, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [9, 10, 1, 0.000, 11.000, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [4, 12, 1, 0.000, 25.600, 0.000, 0.932, None, None, 0.0, None, None, None, None],
#     [12, 13, 1, 0.000, 14.000, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [12, 14, 1, 12.310, 25.590, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [12, 15, 1, 6.620, 13.040, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [12, 16, 1, 9.450, 19.870, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [14, 15, 1, 22.100, 19.970, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [16, 17, 1, 5.240, 19.230, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [15, 18, 1, 10.730, 21.850, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [18, 19, 1, 6.390, 12.920, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [19, 20, 1, 3.400, 6.800, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [10, 20, 1, 9.360, 20.900, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [10, 17, 1, 3.240, 8.450, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [10, 21, 1, 3.480, 7.490, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [10, 22, 1, 7.270, 14.990, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [21, 22, 1, 1.160, 2.360, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [15, 23, 1, 10.000, 20.200, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [22, 24, 1, 11.500, 17.900, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [23, 24, 1, 13.200, 27.000, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [24, 25, 1, 18.850, 32.920, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [25, 26, 1, 25.440, 38.000, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [25, 27, 1, 10.930, 20.870, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [28, 27, 1, 0.000, 39.600, 0.000, 0.968, None, None, 0.0, None, None, None, None],
#     [27, 29, 1, 21.980, 41.530, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [27, 30, 1, 32.020, 60.270, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [29, 30, 1, 23.990, 45.330, 0.000, 1.0, None, None, 0.0, None, None, None, None],
#     [8, 28, 1, 6.360, 20.000, 4.280, 1.0, None, None, 0.0, None, None, None, None],
#     [6, 28, 1, 1.690, 5.990, 1.300, 1.0, None, None, 0.0, None, None, None, None]
# ]

# Pbase = 100
# tol = 0.01

'''
Sistema IEEE 14 Barras
Dados das linhas de transmissão - Matriz DLIN

Cada linha contém:
[De, Para, R (pu), X (pu), Bshunt (pu), Tap, Defasagem (graus), PkmMAX (MW)]

Descrição dos campos:
- De, Para         : Barras de origem e destino
- R (pu)           : Resistência em pu referenciada à base do sistema
- X (pu)           : Reatância em pu referenciada à base do sistema
- Bshunt (pu)      : Susceptância total de linha (1/2 em cada extremidade)
- Tap              : Tap do transformador (1.0 se não houver)
- Defasagem (°)    : Defasagem angular em graus (0 se não houver defasador)
- PkmMAX (MW)      : Capacidade limite de fluxo ativo na linha (MW)

Observações:
- Linhas sem transformadores possuem Tap = 1.0 e Defasagem = 0.
- Valores de R, X e Bshunt estão normalizados em pu.
- PkmMAX pode ser usado para restrições térmicas ou análise de contingências.
'''


# IEEE 14 Bus Test Case - Dados formatados em Python
# Conversão baseada nos dados fornecidos no formato PWF, com valores percentuais já multiplicados por 100.

# ----------------------------------------------------------------------
# DBAR: Dados das barras do sistema elétrico
# Cada entrada: [número, tipo, V (pu), ângulo (°), Pg (MW), Qg (MVAr), Qmin, Qmax, barra controlada,
#                Pl (MW), Ql (MVAr), Sh (MW), área, fator de tensão Vf]
# ----------------------------------------------------------------------
DBAR = [
    [1, 2, 1.0, 0.0,   232.4, -16.9, -999, 999, None,   0.0,   0.0,   0.0, 1, None],
    [2, 1, 1.0, 0.0,  40.0,  42.4, -40.0, 50.0, None, 21.7,  12.7,  0.0, 1, None],
    [3, 1, 1.0, 0.0,   0.0,  23.4,   0.0, 40.0, None, 94.2,  19.0,  0.0, 1, None],
    [4, 0, 1.0, 0.0,   0.0,   0.0, -999, 999, None,  47.8,  -3.9,  0.0, 1, None],
    [5, 0, 1.020, 0.0,    0.0,   0.0, -999, 999, None,   7.6,   1.6,  0.0, 1, None],
    [6, 1, 1.0, 0.0,   0.0,  12.2,  -6.0, 24.0, None, 11.2,   7.5,  0.0, 1, None],
    [7, 0, 1.0, 0.0,   0.0,   0.0, -999, 999, None,   0.0,   0.0,  0.0, 1, None],
    [8, 1, 1.0, 0.0,   0.0,  17.4,  -6.0, 24.0, None,  0.0,   0.0,  0.0, 1, None],
    [9, 0, 1.060, 0.0,   0.0,   0.0, -999, 999, None,  29.5,  16.6, 19.0, 1, None],
    [10, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,   9.0,   5.8,  0.0, 1, None],
    [11, 0, 1.0, 0.0, 0.0,   0.0, -999, 999, None,   3.5,   1.8,  0.0, 1, None],
    [12, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,   6.1,   1.6,  0.0, 1, None],
    [13, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,  13.5,   5.8,  0.0, 1, None],
    [14, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,  14.9,   5.0,  0.0, 1, None]
]

DBAR = [
    [1, 2, 1.060, 0.0,   232.4, -16.3, -999, 999, None,   0.0,   0.0,   0.0, 1, None],
    [2, 1, 1.045, -5.0,   40.0,  44.48, -40.0, 50.0, None, 21.7,  12.7,  0.0, 1, None],
    [3, 1, 1.010, -13.0,   0.0,  25.67,   0.0, 40.0, None, 94.2,  19.0,  0.0, 1, None],
    [4, 0, 1.017, -10.0,   0.0,   0.0, -999, 999, None,  47.8,  -3.9,  0.0, 1, None],
    [5, 0, 1.020, -8.8,    0.0,   0.0, -999, 999, None,   7.6,   1.6,  0.0, 1, None],
    [6, 1, 1.070, -14.0,   0.0, 11.68,  -6.0, 24.0, None, 11.2,   7.5,  0.0, 1, None],
    [7, 0, 1.000, -13.0,   0.0,   0.0, -999, 999, None,   0.0,   0.0,  0.0, 1, None],
    [8, 1, 1.090, -13.0,   0.0,  16.68,  -6.0, 24.0, None,  0.0,   0.0,  0.0, 1, None],
    [9, 0, 1.060, -15.0,   0.0,   0.0, -999, 999, None,  29.5,  16.6, 19.0, 1, None],
    [10, 0, 1.054, -15.0,  0.0,   0.0, -999, 999, None,   9.0,   5.8,  0.0, 1, None],
    [11, 0, 1.059, -15.0,  0.0,   0.0, -999, 999, None,   3.5,   1.8,  0.0, 1, None],
    [12, 0, 1.070, -15.0,  0.0,   0.0, -999, 999, None,   6.1,   1.6,  0.0, 1, None],
    [13, 0, 1.051, -15.0,  0.0,   0.0, -999, 999, None,  13.5,   5.8,  0.0, 1, None],
    [14, 0, 1.038, -16.0,  0.0,   0.0, -999, 999, None,  14.9,   5.0,  0.0, 1, None]
]

DBAR = [
    [1, 2, 1.0, 0.0,   232.4, -16.9, -999, 999, None,   0.0,   0.0,   0.0, 1, None],
    [2, 1, 1.0, 0.0,  40.0,  42.4, -40.0, 50.0, None, 21.7,  12.7,  0.0, 1, None],
    [3, 1, 1.0, 0.0,   0.0,  23.4,   0.0, 40.0, None, 94.2,  19.0,  0.0, 1, None],
    [4, 0, 1.0, 0.0,   0.0,   0.0, -999, 999, None,  47.8,  -3.9,  0.0, 1, None],
    [5, 0, 1.020, 0.0,    0.0,   0.0, -999, 999, None,   7.6,   1.6,  0.0, 1, None],
    [6, 1, 1.0, 0.0,   0.0,  12.2,  -6.0, 24.0, None, 11.2,   7.5,  0.0, 1, None],
    [7, 0, 1.0, 0.0,   0.0,   0.0, -999, 999, None,   0.0,   0.0,  0.0, 1, None],
    [8, 1, 1.0, 0.0,   0.0,  17.4,  -6.0, 24.0, None,  0.0,   0.0,  0.0, 1, None],
    [9, 0, 1.060, 0.0,   0.0,   0.0, -999, 999, None,  29.5,  16.6, 19.0, 1, None],
    [10, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,   9.0,   5.8,  0.0, 1, None],
    [11, 0, 1.0, 0.0, 0.0,   0.0, -999, 999, None,   3.5,   1.8,  0.0, 1, None],
    [12, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,   6.1,   1.6,  0.0, 1, None],
    [13, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,  13.5,   5.8,  0.0, 1, None],
    [14, 0, 1.0, 0.0,  0.0,   0.0, -999, 999, None,  14.9,   5.0,  0.0, 1, None]
]

# ----------------------------------------------------------------------
# DLIN: Dados das linhas de transmissão
# Cada entrada: [de, para, circuito, R (%), X (%), B (MVAr), tap, Tmin, Tmax, fase, Bc, Cn, Ce, Ns]
# ----------------------------------------------------------------------
DLIN = [
    [1, 2, 1, 1.938, 5.917, 5.28, 1.0, None, None, 0.0, None, None, None, None],
    [1, 5, 1, 5.403, 22.304, 4.92, 1.0, None, None, 0.0, None, None, None, None],
    [2, 3, 1, 4.699, 19.797, 4.38, 1.0, None, None, 0.0, None, None, None, None],
    [2, 4, 1, 5.811, 17.632, 3.40, 1.0, None, None, 0.0, None, None, None, None],
    [2, 5, 1, 5.695, 17.388, 3.46, 1.0, None, None, 0.0, None, None, None, None],
    [3, 4, 1, 6.701, 17.103, 1.28, 1.0, None, None, 0.0, None, None, None, None],
    [4, 5, 1, 1.335, 4.211, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [4, 7, 1, 0.0, 20.912, 0.0, 0.978, None, None, 0.0, None, None, None, None],
    [4, 9, 1, 0.0, 55.618, 0.0, 0.949, 0.8, 1.2, 0.0, 9, None, None, None],
    [5, 6, 1, 0.0, 25.202, 0.0, 0.932, 0.8, 1.2, 0.0, 5, None, None, None],
    [6, 11, 1, 9.498, 19.890, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [6, 12, 1, 12.291, 25.581, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [6, 13, 1, 6.615, 13.027, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [7, 8, 1, 0.0, 17.615, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [7, 9, 1, 0.0, 11.001, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [9, 10, 1, 3.181, 8.450, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [9, 14, 1, 12.711, 27.038, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [10, 11, 1, 8.205, 19.207, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [12, 13, 1, 22.092, 19.988, 0.0, 1.0, None, None, 0.0, None, None, None, None],
    [13, 14, 1, 17.093, 34.802, 0.0, 1.0, None, None, 0.0, None, None, None, None]
]

# ----------------------------------------------------------------------
# Potência base do sistema (MW)
# ----------------------------------------------------------------------
Pbase = 100  # Potência base típica para o sistema IEEE 14 barras

# ----------------------------------------------------------------------
# Tolerância para critério de convergência
# ----------------------------------------------------------------------
tol = 0.01/Pbase  # em pu
tol = 0.01


def print_jacobiana_bonita(J, casas_decimais=4):
    """
    Imprime a matriz Jacobiana de forma tabular e legível.
    """
    # Cria rótulos para linhas e colunas
    linhas = [f"L{i}" for i in range(J.shape[0])]
    colunas = [f"C{i}" for i in range(J.shape[1])]

    df = pd.DataFrame(np.round(J, casas_decimais), index=linhas, columns=colunas)
    pd.set_option('display.max_rows', None)
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', None)
    pd.set_option('display.precision', casas_decimais)

    print(df)

    return

# Autor: Gonçalo Fontenele
# Data de criação: 18/05/2025
# Função: montar_ybarra
# Descrição: monta a matriz de admitância nodal Ybarra (completa), incluindo linhas com transformadores,
# defasagens angulares, admitâncias série e shunt por linha e por barra. Retorna também as partes G e B.

def montar_ybarra(NBAR, NLIN, DE, PARA, R, X, BSH, TAP, DEFAS, SHUNT):
    """
    Monta a matriz de admitância Ybarra do sistema.

    Parâmetros:
    - NBAR: número de barras
    - NLIN: número de linhas
    - DE, PARA: listas de barras de origem e destino de cada linha (indexadas a partir de 1)
    - R, X: listas de resistências e reatâncias (pu)
    - BSH: susceptância shunt (pu)
    - TAP: relação de transformação dos transformadores (se for linha normal, TAP = 1)
    - DEFAS: defasagem angular dos trafos (rad)
    - SHUNT: admitância shunt em cada barra (pu)

    Retorna:
    - Ybarra: matriz de admitância completa
    - G: parte real da matriz
    - B: parte imaginária da matriz
    """

    # Inicialização da matriz Ybarra como matriz NBAR x NBAR de números complexos
    Ybarra = np.zeros((NBAR, NBAR), dtype=complex)

    # Cálculo da admitância série de cada linha (Ykm = 1 / Z)
    Ykm = 1 / (R + 1j * X)

    # Cálculo da admitância shunt (representada por susceptância Bsh) de cada linha
    Bsh = 1j * BSH

    # Loop para montagem da matriz Ybarra (somente componentes das linhas)
    for k in range(NLIN):
        x = int(DE[k]) - 1      # índice da barra DE (ajuste de indexação para Python)
        y = int(PARA[k]) - 1    # índice da barra PARA
        tap_k = TAP[k]          # relação de transformação (TAP)
        defas_k = DEFAS[k]      # defasagem angular do trafo (rad)

        # Adição do termo série e shunt da linha na diagonal da barra "de"
        Ybarra[x, x] += Bsh[k] + (1 / tap_k**2) * Ykm[k]

        # Adição do termo série e shunt da linha na diagonal da barra "para"
        Ybarra[y, y] += Bsh[k] + Ykm[k]

        # Termos fora da diagonal com ajuste de tap e defasagem (ângulo)
        Ybarra[x, y] -= Ykm[k] * (1 / tap_k) * np.exp(-1j * defas_k)
        Ybarra[y, x] -= Ykm[k] * (1 / tap_k) * np.exp(1j * defas_k)

    # Adição das admitâncias shunt associadas a cada barra diretamente (elementos da diagonal)
    for k in range(NBAR):
        Ybarra[k, k] += 1j * SHUNT[k]

    # Extração das partes real (G) e imaginária (B) da matriz Ybarra
    G = np.real(Ybarra)
    B = np.imag(Ybarra)

    return Ybarra, G, B

# Autor: Gonçalo Fontenele
# Data de criação: 18/05/2025
# Função: montar_matriz_jacobiana
# Descrição: monta a matriz Jacobiana do método de Newton-Raphson para fluxo de potência,
# considerando barras tipo PQ, PV e Swing. A Jacobiana é composta pelas submatrizes H, N, M, L.

def montar_matriz_jacobiana(NBAR, V, TETA, Pcalc, Qcalc, G, B, TIPO):
    # Inicialização das submatrizes H, N, M, L com zeros (todas são NBAR x NBAR)
    H = np.zeros((NBAR, NBAR))  # Derivadas de P em relação a ângulos (∂P/∂θ)
    N = np.zeros((NBAR, NBAR))  # Derivadas de P em relação a tensões (∂P/∂V)
    M = np.zeros((NBAR, NBAR))  # Derivadas de Q em relação a ângulos (∂Q/∂θ)
    L = np.zeros((NBAR, NBAR))  # Derivadas de Q em relação a tensões (∂Q/∂V)

    # Loop para montar as derivadas de todas as submatrizes
    for k1 in range(NBAR):
        for k2 in range(NBAR):
            if k1 == k2:
                # Elementos diagonais (derivadas parciais considerando a própria barra)
                H[k1, k1] = -(Qcalc[k1] + V[k1]**2 * B[k1, k1])
                N[k1, k1] = (1 / V[k1]) * (Pcalc[k1] + V[k1]**2 * G[k1, k1])
                M[k1, k1] = Pcalc[k1] - V[k1]**2 * G[k1, k1]
                L[k1, k1] = (1 / V[k1]) * (Qcalc[k1] - V[k1]**2 * B[k1, k1])

                # Ajustes com base no tipo da barra
                if TIPO[k1] == 2:  # Barra swing: ângulo e tensão fixos
                    H[k1, k1] = 1e10   # Impede alterações em ∆θ
                    L[k1, k1] = 1e10   # Impede alterações em ∆V
                if TIPO[k1] == 1:  # Barra PV: ângulo e potência ativa fixos
                    L[k1, k1] = 1e10   # Impede alterações em ∆V (Q especificado)
            else:
                # Elementos fora da diagonal (entre barras diferentes)
                delta_theta = TETA[k1] - TETA[k2]

                # Derivadas parciais conforme a equação do fluxo de potência
                H[k1, k2] = V[k1] * V[k2] * (G[k1, k2] * np.sin(delta_theta) - B[k1, k2] * np.cos(delta_theta))
                N[k1, k2] = V[k1] * (G[k1, k2] * np.cos(delta_theta) + B[k1, k2] * np.sin(delta_theta))
                M[k1, k2] = -V[k1] * V[k2] * (G[k1, k2] * np.cos(delta_theta) + B[k1, k2] * np.sin(delta_theta))
                L[k1, k2] = V[k1] * (G[k1, k2] * np.sin(delta_theta) - B[k1, k2] * np.cos(delta_theta))

    # Montagem da matriz Jacobiana 2*NBAR x 2*NBAR com as 4 submatrizes
    Jac = np.block([[H, N],   # Parte superior (∂P/∂θ | ∂P/∂V)
                    [M, L]])  # Parte inferior (∂Q/∂θ | ∂Q/∂V)

    return Jac

def adiciona_controles_delta_y(DELTA_Y, V, V_CONTROLADA, LC):
    """
    Adiciona equações de controle de tensão (tap controlado) ao vetor ΔY.
    """
    # Garante que DELTA_Y é vetor 1D para concatenar
    DELTA_Y = DELTA_Y.flatten()

    taps_controlados = sum(1 for barra in LC if barra is not None)
    deltaY = np.concatenate([DELTA_Y, np.zeros(taps_controlados)])

    for tap_count, barra_controlada in enumerate([b for b in LC if b is not None]):
        idx = len(deltaY) - taps_controlados + tap_count
        deltaY[idx] = V_CONTROLADA[barra_controlada - 1] - V[barra_controlada - 1]

    return deltaY.reshape(-1, 1)  # Retorna como vetor coluna

def adicionar_controles_jacobiana(NBAR, JACOBIANA, V, TETA, G, B, TIPO, TAP, DE, PARA, BC, LC):
    """
    Adiciona controles de tap variável na matriz Jacobiana.

    Parâmetros:
        V          : vetor de tensões [pu]
        TETA       : vetor de ângulos [rad]
        G          : matriz de condutâncias
        B          : matriz de susceptâncias
        TIPO       : vetor com tipos de barras (0=PQ, 1=PV, 2=Swing)
        TAP        : vetor de taps atuais
        BC         : dicionário ou matriz da Jacobiana já existente
        LC         : vetor que indica a barra controlada para cada transformador
                     (None onde não há controle de tap)

    Retorna:
        Jacobiana ampliada (numpy.ndarray)
    """

    # Número inicial de variáveis
    nVARIAVEIS = 2 * NBAR

    # Inicializa Jacobiana ampliada (caso BC já exista pode ser passado)
    J = JACOBIANA.copy()

    # Conta quantos taps controlados existem
    taps_controlados = sum([1 for barra in LC if barra is not None])

    # Matrizes auxiliares de zeros
    zeros_col = np.zeros((J.shape[0], taps_controlados))    # Zeros para colunas novas
    zeros_row = np.zeros((taps_controlados, J.shape[1]))    # Zeros para linhas novas
    zeros_corner = np.zeros((taps_controlados, taps_controlados))  # Bloco inferior direito (tap x tap)

    # Monta a Jacobiana expandida
    J = np.block([
        [J,         zeros_col],
        [zeros_row, zeros_corner]
    ])

    # Índice inicial para taps (após todas as variáveis de θ e V_PQ)
    idx_tap_inicial = nVARIAVEIS - 1

    tap_count = 0

    for k, barra_controlada in enumerate(LC):
        if barra_controlada is not None:
            tap_count += 1

            barra_k = DE[k]-1
            barra_m = PARA[k]-1

            # Dados elétricos da linha
            gkm = G[barra_k, barra_m]
            bkm = B[barra_k, barra_m]

            # Tensões e ângulos
            Vk = V[barra_k]
            Vm = V[barra_m]
            teta_k = TETA[barra_k]
            teta_m = TETA[barra_m]

            # Atuação do limite
            tap = TAP[k] if TAP[k] != 0 else 1.0

            # Índices na Jacobiana
            idx_theta_k = barra_k
            idx_theta_m = barra_m
            idx_v_k = NBAR + barra_k # Considera que existem todas as linhas na matriz
            idx_v_m = NBAR + barra_m # Considera que existem todas as linhas na matriz

            idx_tap = idx_tap_inicial + tap_count

            # Cálculo das derivadas
            dPk_da = 2 * tap * Vk**2 * gkm - Vk * Vm * (gkm * np.cos(teta_k - teta_m) + bkm * np.sin(teta_k - teta_m))
            dQk_da = -2 * tap * Vk**2 * bkm + Vk * Vm * (bkm * np.cos(teta_k - teta_m) - gkm * np.sin(teta_k - teta_m))

            dPm_da = -Vk * Vm * gkm * np.cos(teta_m - teta_k) + Vk * Vm * bkm * np.sin(teta_m - teta_k) #troquei o sinal de +bkm para -bkm 
            dQm_da = Vk * Vm * (bkm * np.cos(teta_m - teta_k) + gkm * np.sin(teta_m - teta_k))#troquei o sinal de -gkm para +gkm

            # Preenchimento na Jacobiana
            # dPk/da
            J[idx_theta_k, idx_tap] += dPk_da

            # dPm/da
            J[idx_theta_m, idx_tap] += dPm_da

            # dQk/da (se barra k for PQ)
            J[idx_v_k, idx_tap] += dQk_da

            # dQm/da (se barra m for PQ)
            J[idx_v_m, idx_tap] += dQm_da

            # dV/dV (se barra m for PQ)
            # A tensão barra controlada fica na segunda parte do delta y, que foi montado concatenando Delta P e em seguida Delta Q
            J[idx_tap, NBAR + (barra_controlada-1)] += 1 # Feito considerando que a parte superior é uma constante

            # As linhas extras na Jacobiana para as equações de controle podem ser incluídas aqui
            # Exemplo: manter Vm = valor desejado

    return J

def atualiza_taps(TAPS, delta_SOLUCAO, LC, NBAR):
    """
    Atualiza os valores dos taps que estão controlando tensões.

    Parâmetros:
    - TAPS: vetor atual de taps
    - delta_SOLUCAO: vetor solução da iteração atual (delta_theta, delta_V, delta_taps)
    - LC: lista de controle de tensão por tap (None se não controla)
    - NVARIAVEIS: número de variáveis antes das variáveis de tap (theta + V_PQ)

    Retorna:
    - TAPS atualizado
    """
    taps_controlados_idx = [i for i, barra in enumerate(LC) if barra is not None]
    taps_controlados = len(taps_controlados_idx)

    for pos, idx_tap in enumerate(taps_controlados_idx):
        idx = len(delta_SOLUCAO) - taps_controlados + pos
        TAPS[idx_tap] += delta_SOLUCAO[idx]
        print(f"Tap {idx_tap} atualizado para {TAPS[idx_tap]}")

    return TAPS

def relatorio_transformadores(DE, PARA, FLUXO, TAP, LC, nomes_barras=None):
    """
    Imprime um relatório no estilo ANAREDE para transformadores/linhas com tap.

    Parâmetros:
    - DE, PARA: listas de barras de origem e destino
    - FLUXO: matriz com colunas [Pkm, Pmk, Pkm_max, folga, fluxo_utilizado, Qkm]
    - TAP: vetor de taps atuais
    - LC: lista de barras controladas (None se não houver controle)
    - nomes_barras: lista com nomes das barras (opcional)
    """

    print("\nRELATÓRIO DE TRANSFORMADORES COM CONTROLE DE TAP")
    print("X-------X-----------------X-----X-----------------X-----X-------X-------X--------X")
    print(" DE     NOME_ORIGEM       NC    PARA   NOME_DESTINO     MW     Mvar    MVA     TAP  TIPO")
    print("X-------X-----------------X-----X-----------------X-----X-------X-------X--------X")

    for k in range(len(DE)):
        de = DE[k]
        para = PARA[k]
        nome_de = nomes_barras[de - 1] if nomes_barras else f"Barra-{de:02d}"
        nome_para = nomes_barras[para - 1] if nomes_barras else f"Barra-{para:02d}"

        pkm = FLUXO[k, 0]
        qkm = FLUXO[k, 5] if FLUXO.shape[1] > 5 else 0.0
        mva = (pkm**2 + qkm**2)**0.5
        tap = TAP[k]
        tipo = "*" if LC[k] is not None else "F"  # * para variável, F para fixo

        print(f" {de:<7} {nome_de:<17} 1     {para:<5} {nome_para:<17} {pkm:7.1f} {qkm:7.1f} {mva:7.1f}  {tap:6.3f}   {tipo:>2}")

    print("X-------X-----------------X-----X-----------------X-----X-------X-------X--------X")
    return


def newton_raphson_flow(DBAR, DLIN, Pbase = 1.0, tolerancia = 0.003, iteracao_max = 20, printar_relatorio=True):
    tolerancia_tensao = tolerancia/10
    # Número de barras (NBAR)
    NBAR = len(DBAR)  # número de linhas da lista DBAR

    # Número de linhas (NLIN) e número de colunas (AUX) da matriz DLIN
    NLIN = len(DLIN)        # número de linhas da lista DLIN

    # --- Separação de DBAR em vetores numpy (ordenados por índice) ---
    # DBAR contém os dados das barras do sistema

    TIPO = np.array([row[1] for row in DBAR])            # Tipo da barra (1 = PQ, 2 = PV, 3 = Slack)
    V = np.array([row[2] for row in DBAR])               # Módulo da tensão (em pu)
    V_ESP = copy.deepcopy(V)    
    TETA = np.array([row[3] * math.pi / 180 for row in DBAR])  # Ângulo da tensão (graus → rad)
    TETA_ESP = copy.deepcopy(TETA)
    PG = np.array([row[4] / Pbase for row in DBAR])      # Potência ativa gerada (MW → pu)
    QG = np.array([row[5] / Pbase for row in DBAR])      # Potência reativa gerada (MVAr → pu)
    QN = np.array([row[6] / Pbase for row in DBAR])      # Limite inferior da geração reativa (MVAr → pu)
    QM = np.array([row[7] / Pbase for row in DBAR])      # Limite superior da geração reativa (MVAr → pu)
    BC = np.array([row[8] for row in DBAR])             # Barra controlada (se houver)
    PD = np.array([row[9] / Pbase for row in DBAR])      # Potência ativa demandada (MW → pu)
    QD = np.array([row[10] / Pbase for row in DBAR])     # Potência reativa demandada (MVAr → pu)
    SHUNT = np.array([row[11] / Pbase for row in DBAR])  # Susceptância do shunt (MVAr → pu)

    # --- Separação de DLIN em vetores numpy (ordenados por índice) ---
    # DLIN contém os dados das linhas do sistema

    DE = np.array([row[0] for row in DLIN])              # Barra de origem da linha
    PARA = np.array([row[1] for row in DLIN])            # Barra de destino da linha
    R = np.array([row[3] / 100 for row in DLIN])         # Resistência série da linha (% → pu)
    X = np.array([row[4] / 100 for row in DLIN])         # Reatância série da linha (% → pu)
    BSH = np.array([(row[5] / 2) / Pbase for row in DLIN])  # Susceptância total da linha (dividida entre as extremidades e normalizada)
    TAP = np.array([row[6] for row in DLIN])             # Tap da linha (se houver transformador, normalmente ≠ 1)
    DEFAS = np.array([row[9] for row in DLIN])           # Defasagem angular associada ao tap (em graus ou rad, conforme o caso)
    LC = np.array([row[10] for row in DLIN])            # Barra/Linha controlada

    # Seleção das Barras PV (TIPO == 1)
    PV = np.where(TIPO == 1)[0]
    NPV = len(PV)

    # Seleção das Barras PQ (TIPO == 0)
    PQ = np.where(TIPO == 0)[0]
    NPQ = len(PQ)

    # Contabilização do numero de barras controladas
    NCTAP = sum(1 for barra in LC if barra is not None)
    NCV = sum(1 for barra in BC if barra is not None)

    # Matriz de Fluxo nas Linhas (5 colunas)
    FLUXO = np.zeros((NLIN, 6))  # Adiciona uma coluna extra para o fluxo reativo
    FLUXO[:, 2] = np.array([linha[12] if len(linha) > 14 else 0 for linha in DLIN])  # PkmMAX

    # Inicialização
    i = 0  # Número de Iterações

    convergiu = False  # Flag para verificar divergência

    while not convergiu and i < (iteracao_max+1):
        # Tensões em coordenadas retangulares (TETA em radianos)
        x = V * np.cos(TETA)
        y = V * np.sin(TETA)
        Vret = x + 1j * y  # Forma retangular da tensão

        # Valores Especificados de Potência (Líquido)
        Pesp = PG - PD
        Qesp = QG - QD

        # Montagem da matriz Ybarra, somente se na primeira iteração ou se houver algum controle ativo
        Ybarra, G, B = montar_ybarra(NBAR, NLIN, DE, PARA, R, X, BSH, TAP, DEFAS, SHUNT)

        # NOTA:
        # AQUI SERÁ NECESSÁRIO ALTERAR A YBARRA SEMPRE QUE TIVER UM CONTROLE ACIONADO
        # ACREDITO QUE DÊ PARA RODAR ALGUMAS ITERAÇÕES E TER DUAS TOLERÂNCIAS
        # CHEGANDO EM 30 % DA TOLERÂNCIA MÁXIMA, SOLTARIA OS CONTROLES

        # Correntes injetadas: I = Ybarra * V
        I = Ybarra @ Vret  # Produto matricial

        # Potência complexa injetada: S = V * conj(I)
        S = Vret * np.conj(I)
        Pcalc = np.real(S)  # Potência ativa calculada
        Qcalc = np.imag(S)  # Potência reativa calculada

        # Inicialização dos resíduos
        delta_P = Pesp - Pcalc
        delta_Q = Qesp - Qcalc

        # Ajuste dos resíduos com base no tipo de barra
        for k in range(NBAR):
            if TIPO[k] == 2:  # Slack (tipo 2): não há resíduos
                delta_P[k] = 0
                delta_Q[k] = 0
            elif TIPO[k] == 1:  # PV (tipo 1): não há resíduo de Q
                delta_Q[k] = 0

        # Vetor de resíduos (coluna)
        delta_Y = np.concatenate([delta_P, delta_Q]).reshape(-1, 1)
        if Controle_CTAP:
            delta_Y = adiciona_controles_delta_y(delta_Y, V, V_ESP, LC)
            # taps_controlados = sum(1 for barra in LC if barra is not None)
            # deltaV = np.zeros(taps_controlados)

            # for tap_count, barra_controlada in enumerate([b for b in LC if b is not None]):
            #     deltaV[tap_count] = V_ESP[barra_controlada - 1] - V[barra_controlada - 1]

            # deltaV = deltaV.reshape(-1, 1)

            # # Erro máximo (critério de convergência)
            # MAX_V = np.max(np.abs(deltaV))
            # indice_MAX_V = np.argmax(np.abs(deltaV))
            # print('Mismatch máximo está em', MAX_V, 'no item', indice_MAX_V)

        # Erro máximo (critério de convergência)
        MAX_Y = np.max(np.abs(delta_Y))
        indice_MAX_Y = np.argmax(np.abs(delta_Y))
        print('Mismatch máximo está em', MAX_Y, 'no item', indice_MAX_Y)

        if MAX_Y < tolerancia:
            convergiu = True
            break

        # if Controle_CTAP:
        #     delta_Y = np.concatenate([delta_Y, deltaV]).reshape(-1, 1)

        i += 1  # Incrementa o contador de iterações
        print("Iniciando iteracao ", i)

        # Matriz Jacobiana
        Jac = montar_matriz_jacobiana(NBAR, V, TETA, Pcalc, Qcalc, G, B, TIPO)
        if Controle_CTAP:
            Jac = adicionar_controles_jacobiana(NBAR, Jac, V, TETA, G, B, TIPO, TAP, DE, PARA, BC, LC)

        # delta_Y deve ser um vetor coluna numpy com dimensão (2*NBAR, 1)
        # Jac é a matriz Jacobiana 2*NBAR x 2*NBAR

        # Resolução do sistema linear: Jac * delta_SOLUCAO = delta_Y
        delta_SOLUCAO = np.linalg.solve(Jac, delta_Y).flatten()

        # Atualização dos vetores TETA e V
        TETA += delta_SOLUCAO[0:NBAR]            # primeiros NBAR elementos são delta_TETA
        V += delta_SOLUCAO[NBAR:2*NBAR]             # próximos NBAR elementos são delta_V

        if Controle_CTAP:
            TAP = atualiza_taps(TAP, delta_SOLUCAO, LC, NBAR)

    for k in range(NLIN):
        K = DE[k] - 1
        M = PARA[k] - 1

        tap = TAP[k] if TAP[k] != 0 else 1.0
        defas = DEFAS[k]

        Vk = V[K]
        Vm = V[M]
        teta_k = TETA[K]
        teta_m = TETA[M]
        gkm = G[K, M]
        bkm = B[K, M]
        bsh = BSH[k]

        delta_km = (teta_k - teta_m) + defas
        delta_mk = (teta_m - teta_k) + defas

        # Fluxo de potência ativa
        fluxo_1 = -(tap * Vk)**2 * gkm + tap * Vk * Vm * (gkm * np.cos(delta_km) + bkm * np.sin(delta_km))
        fluxo_2 = -(tap * Vm)**2 * gkm + tap * Vm * Vk * (gkm * np.cos(delta_mk) + bkm * np.sin(delta_mk))

        # Fluxo de potência reativa
        reat_1 = -(tap**2) * (bsh + bkm) * Vk**2 + tap * Vk * Vm * (bkm * np.cos(delta_km) - gkm * np.sin(delta_km))
        reat_2 = -(tap**2) * (bsh + bkm) * Vm**2 + tap * Vm * Vk * (bkm * np.cos(delta_mk) - gkm * np.sin(delta_mk))

        # Conversão para base real (MW, MVAr)
        fluxo_1 *= Pbase
        fluxo_2 *= Pbase
        reat_1 *= Pbase
        reat_2 *= Pbase

        FLUXO[k, 0] = fluxo_1  # Pkm
        FLUXO[k, 1] = fluxo_2  # Pmk

        if abs(fluxo_1) >= abs(fluxo_2):
            FLUXO[k, 3] = FLUXO[k, 2] - abs(fluxo_1)
            FLUXO[k, 4] = abs(fluxo_1)
            FLUXO[k, 5] = reat_1  # fluxo reativo direto
        else:
            FLUXO[k, 3] = FLUXO[k, 2] - abs(fluxo_2)
            FLUXO[k, 4] = abs(fluxo_2)
            FLUXO[k, 5] = reat_2  # fluxo reativo reverso

    if not convergiu:
        print('O caso Divergiu')
    else:
        print('='*108)
        print(f'- Número de Iterações: {i}')
        print('='*108)
        print(f'- Resíduo Máximo: {MAX_Y:.6g} < Tolerância de {tolerancia:.3f}')
        print('='*108)
        print('- Dados Finais de Barra (pu):\n')
        print(f'{"Nº":>2} {"Tipo":>4} {"V":>6} {"Ang(°)":>8} {"PG":>8} {"QG":>8} {"Qmín":>8} {"Qmáx":>8} {"Pd":>8} {"Qd":>8}')
       
        # Monta matriz de dados para impressão
        dados_barra = np.column_stack((
            np.arange(1, NBAR+1),              # Nº
            TIPO,                             # Tipo
            V,                                # Tensão
            TETA * 180 / np.pi,               # Ângulo em graus
            (Pcalc + PD) * Pbase,             # PG
            (Qcalc + QD) * Pbase,             # QG
            QN * Pbase,                      # Qmín
            QM * Pbase,                      # Qmáx
            PD * Pbase,                      # Pdemanda
            QD * Pbase                       # Qdemanda
        ))

        # Imprime linha a linha formatada
        for linha in dados_barra:
            print(f'\t{int(linha[0]):<4}\t{int(linha[1]):<6}\t{linha[2]:<7.3f}\t{linha[3]:<10.1f}\t'
                f'{linha[4]:<10.1f}\t{linha[5]:<10.1f}\t{linha[6]:<10.1f}\t{linha[7]:<10.1f}\t'
                f'{linha[8]:<10.1f}\t{linha[9]:<10.1f}')

        print('='*108)
        print('Fluxo de Potência Ativa entre as Barras')
        print('='*108)
        print(f'\t{"DE":<6}\t{"PARA":<6}\t{"DE-PARA":<10}\t{"PARA-DE":<10}\t{"FLUXO MAX":<10}\t{"FOLGA":<10}')

        # Imprime dados de fluxo: DE, PARA, FLUXO[:,1], FLUXO[:,2], FLUXO[:,3], FLUXO[:,4]
        for i in range(len(DE)):
            print(f'\t{int(DE[i]):<6}\t{int(PARA[i]):<6}\t{FLUXO[i,0]:<10.4f}\t{FLUXO[i,1]:<10.4f}\t{FLUXO[i,2]:<10.4f}\t{FLUXO[i,3]:<10.4f}')

        print('='*108)

        if printar_relatorio:
            nomes = [f"Barra-{i+1:02d}" for i in range(NBAR)]
            relatorio_transformadores(DE, PARA, FLUXO, TAP, LC, nomes_barras=nomes)

    return V, TETA, FLUXO

tensoes, thetas, fluxos = newton_raphson_flow(DBAR, DLIN, Pbase = Pbase, tolerancia = tol, iteracao_max=20)
